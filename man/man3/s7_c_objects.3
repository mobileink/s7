.Dd July 10, 2021
.Dt S7 3
.Os
.Sh NAME
.Nm s7_is_c_object,
.Nm s7_c_object_*...,
.Nm s7_make_c_object_*...,
.Nm s7_c_type_*...
.Nd C object functions
.Sh LIBRARY
.Lb libs7
.Sh SYNOPSIS
.In s7.h
.Ft bool
.Fn s7_is_c_object "s7_pointer p"
.Ft s7_int
.Fn s7_c_object_type "s7_pointer obj"
.Ft void
.Fn *s7_c_object_value "s7_pointer obj"
.Ft void
.Fn *s7_c_object_value_checked "s7_pointer obj" "s7_int type"
.Ft s7_pointer
.Fn s7_make_c_object "s7_scheme *sc, s7_int type, void *value"
.Ft s7_pointer
.Fn s7_make_c_object_with_let "s7_scheme *sc, s7_int type, void *value, s7_pointer let"
.Ft s7_pointer
.Fn s7_make_c_object_without_gc "s7_scheme *sc, s7_int type, void *value"
.Ft s7_pointer
.Fn s7_c_object_let "s7_pointer obj"
.Ft s7_pointer
.Fn s7_c_object_set_let "s7_scheme *sc, s7_pointer obj, s7_pointer e"
.Ft s7_int
.Fn s7_make_c_type "s7_scheme *sc, const char *name"
.Ft void
.Fn s7_c_type_set_free "s7_scheme *sc, s7_int tag, void (*gc_free)(void *value)"
.Ft void
.Fn s7_c_type_set_mark "s7_scheme *sc, s7_int tag, void (*mark)(void *value)"
.Ft void
.Fn s7_c_type_set_equal "s7_scheme *sc, s7_int tag, bool (*equal)(void *value1, void *value2)"
.Ft void
.Fn s7_c_type_set_gc_free "s7_scheme *sc, s7_int tag, s7_pointer (*gc_free)   (s7_scheme *sc, s7_pointer obj)"
.Ft void
.Fn s7_c_type_set_gc_mark "s7_scheme *sc, s7_int tag, s7_pointer (*mark)      (s7_scheme *sc, s7_pointer obj)"
.Ft void
.Fn s7_c_type_set_is_equal "s7_scheme *sc, s7_int tag, s7_pointer (*is_equal)  (s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_is_equivalent "s7_scheme *sc, s7_int tag, s7_pointer (*is_equivalent)(s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_ref "s7_scheme *sc, s7_int tag, s7_pointer (*ref)       (s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_set "s7_scheme *sc, s7_int tag, s7_pointer (*set)       (s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_length "s7_scheme *sc, s7_int tag, s7_pointer (*length)    (s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_copy "s7_scheme *sc, s7_int tag, s7_pointer (*copy)      (s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_fill "s7_scheme *sc, s7_int tag, s7_pointer (*fill)      (s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_reverse "s7_scheme *sc, s7_int tag, s7_pointer (*reverse)   (s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_to_list "s7_scheme *sc, s7_int tag, s7_pointer (*to_list)   (s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_to_string "s7_scheme *sc, s7_int tag, s7_pointer (*to_string) (s7_scheme *sc, s7_pointer args)"
.Ft void
.Fn s7_c_type_set_getter "s7_scheme *sc, s7_int tag, s7_pointer getter"
.Ft void
.Fn s7_c_type_set_setter "s7_scheme *sc, s7_int tag, s7_pointer setter"

.Sh DESCRIPTION
These functions create and configure new Scheme types and objects.
C-objects in Scheme usually correspond to an instance of a struct in C which you want to access from Scheme. The normal sequence is:
.Bl -enum --offset indent
.It
define a new c-type via
.Fn s7_make_c_type
.It
call type configuration functions (e.g.
.Fn s7_c_type_set_length ,
.Fn s7_c_type_set_is_equal ,
etc.) to specialize the behavior of objects of the c-type
.It
call
.Fn s7_make_c_object
to wrap a C struct as man object of the c-type.
.El
.Pp
.Fn s7_make_c_type "s7_scheme *sc, const char *name"
Creates a new C-based type
.Em name
for Scheme.  Takes an arbitrary name string, used by object->string to identify the type, and returns an
.Em s7_int ,
the type "tag" used to indentify this type in many of the other functions.
.Pp
.Fn s7_is_c_object "s7_pointer p"
Returns true if
.Em p
is a c-object
.Pp
.Fn s7_c_object_type
Returns the c-bject's
.Em type
(the
.Em s7_int
passed to
.Sm off
.Fn s7_make_c_object
)
.Sm on
.Pp
.Fn s7_c_object_value
Returns the value bound to that c_object (the void*
.Em value
of
.Sm off
.Fn s7_make_c_object
)
.Sm on
.Pp
.Fn *s7_c_object_value_checked
Like
.F s7_c_object_value ,
but it first checks that the object type matches the given
.Em type .
.Pp
.Fn s7_make_c_object "s7_scheme *sc, s7_int type, void *value"
Creates a new Scheme entity of the given
.Em type
with the given (uninterpreted)
.Em value
.Pp
.Fn s7_make_c_object_with_let
.Pp
.Fn s7_make_c_object_without_gc
Makes a c-object of the given type, but the
.Em gc_free
function (configured by
.Fn s7_c_type_set_gc_free ? )
won't be called when the
.Em s7_cell
that holds the C data is freed for reuse.
.Pp
.Fn s7_c_object_let
.Pp
.Fn s7_c_object_set_let
s7_c_object_let and s7_c_object_set_let manage the c-object's local environment. These two functions need to check that they are passed the correct number of arguments.
.Pp
.Sh TYPE CONFIGURATION
.Pp
The following functions configure c-types with callback functions that implement core functionality, e.g. length, to_string, etc.
.Pp
Old style free/mark/equal:
.Bl -inset -offset indent
.It
.Fn s7_c_type_set_free
Sets the function that is called by the GC when a Scheme c-object is garbage-collected. You normally use this to free the associated C value (the instance of the struct). To get that value, call
.Fn s7_c_object_value .
It returns the void* pointer that you originally passed to
.Fn s7_make_c_object .
.It
.Fn s7_c_type_set_mark
Sets the function that is called by the GC during its marking phase. Any
.Fn s7_pointer
value local to your C struct should be marked explicitly at this time, or the GC will free it. Use
.Fn s7_mark
for this.
.It
.Fn s7_c_type_set_equal
.El
.Pp
New style free/mark/equal and equivalent:
.Bl -inset -offset indent
.It
.Fn s7_c_type_set_gc_free
.It
.Fn s7_c_type_set_gc_mark
.It
.Fn s7_c_type_set_is_equal
Sets the function called when s7 sees a c-object of the current type as an argument to
.Em equal? .
When called, this function can assume that the first argument is a c-object of the current type, but the second argument can be anything.
.It
.Fn s7_c_type_set_is_equivalent
Compare objects as in
.Em equivalent?
See
.Fn s7_c_type_set_is_equal
above.
.El
.Pp
.Fn s7_c_type_set_ref "s7_scheme *sc, s7_int tag, s7_pointer (*ref)(s7_scheme *sc, s7_pointer args)"
Sets the function called when the c-object is treated as an applicable object in Scheme; i.e. at the car of a list. The rest of the list is passed to the ref function as the arguments:
.Em (obj ...)
in Scheme calls the function set as the "ref" function.
.Pp
.Fn s7_c_type_set_set
Sets the function called when a c-object of this type occurs as the target of a generalized
.Em set!
application, e.g.
.Em (set! (obj ...) val) .
Scheme calls the "set" function, and the arguments in the set! form are passed as a flattened list.
.Pp
.Fn s7_c_type_set_length
The function called when the object is asked what its length is.
.Pp
.Fn s7_c_type_set_copy
The function called when a copy of the object is needed.
.Pp
.Fn s7_c_type_set_fill
The function called to fill the object with some value.
.Pp
.Fn s7_c_type_set_reverse
Similarly...
.Pp
.Fn s7_c_type_set_to_list
.Pp
.Fn s7_c_type_set_to_string
object->string for an object of this type
.Pp
.Fn s7_c_type_set_getter
.Pp
.Fn s7_c_type_set_setter
.Pp
.Fn s7_mark
Marks any Scheme c_object as in-use (use this in the mark function to mark any embedded
.Em s7_pointer
variables).
.Pp
The
.Fn s7_c_type_set_getter
and
.Fn s7_c_type_set_setter
functions help the optimizer handle applicable c-objects.
The
.Em let
in
.Fn s7_make_c_object_with_let
and
.Fn s7_c_object_set_let
needs to be GC protected by marking it in the c_object's mark function.
.Sh RETURN VALUES
Upon successful completion
.Fn foo
and
.Fn bar
return a
.Tn FILE
pointer.
Otherwise,
.Dv NULL
is returned and the global variable
.Va errno
is set to indicate the error.
.Sh EXAMPLES

 s7_define_function(s7, "notify-C", scheme_set_notification, 2, 0, false, "called if notified-var is set!");
 s7_define_variable(s7, "notified-var", s7_make_integer(s7, 0));
 s7_set_setter(s7, s7_make_symbol(s7, "notified-var"), s7_name_to_value(s7, "notify-C"));

.Sh ERRORS
.Sh SEE ALSO
.Xr s7_c_pointers 3 ,
.Xr SRFI 17 Generalize set! https://srfi.schemers.org/srfi-17/srfi-17.html
.Xr Guile manual 6.7.8 Procedures with Setters https://www.gnu.org/software/guile/manual/html_node/Procedures-with-Setters.html
.Sh AUTHORS
.An Bill Schottstaedt Aq Mt bil@ccrma.stanford.edu
.An Mike Scholz
provided the FreeBSD support (complex trig funcs, etc)
.An Rick Taube, Andrew Burnson, Donny Ward, and Greg Santucci
provided the MS Visual C++ support
.An Kjetil Matheussen
provided the mingw support
.An chai xiaoxiang
provided the msys2 support
